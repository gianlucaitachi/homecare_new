# Homecare New

## Project Purpose
Homecare New is an end-to-end platform that helps home health agencies coordinate caregivers, schedule visits, and share care plans with families. The goal is to provide a lightweight reference implementation that demonstrates how the backend API and the Flutter mobile client interact to deliver core workflows such as onboarding a patient, assigning a caregiver, and capturing visit notes in the field.

## Backend Service
The repository now includes a minimal Dart backend skeleton located in `backend/`. It uses [`shelf`](https://pub.dev/packages/shelf) with [`shelf_router`](https://pub.dev/packages/shelf_router) to expose HTTP routes and [`dotenv`](https://pub.dev/packages/dotenv) so developers can configure runtime settings from a local `.env` file.

### Prerequisites
- Dart SDK 3.0 or newer

### Environment Variables
Create a `backend/.env` file to override defaults exposed by the development server. The only required value today is the port the server should bind to:

```
PORT=8080
```

The `.env` file is optional—if it is missing or `PORT` is not set, the server falls back to port `8080`. You can still supply the same variables via the regular shell environment if you prefer.

### Running the Backend Locally
1. Fetch the Dart dependencies: `dart pub get --directory backend`.
2. (Optional) Create or update `backend/.env` with the desired `PORT` value.
3. Start the development server:
   ```
   dart run backend/bin/server.dart
   ```
4. Verify the health endpoint at `http://localhost:<PORT>/health`. The server responds with `{"status":"ok"}` to confirm it is running.

### Task Management API
All task routes are protected by the JWT middleware—include an `Authorization: Bearer <token>` header from the authentication endpoints.

| Endpoint | Method | Description | Request Body |
| --- | --- | --- | --- |
| `/api/tasks` | GET | Returns all persisted tasks. | — |
| `/api/tasks` | POST | Creates a task. Generates a unique `qr_code` payload used for completion. | `{ "title": "string", "assignee": "string", "dueDate": "ISO-8601 string", "status": "string (optional)" }` |
| `/api/tasks/<id>` | PUT | Updates mutable fields (`title`, `assignee`, `dueDate`, `status`). | Any subset of `{ "title": "string", "assignee": "string", "dueDate": "ISO-8601 string", "status": "string" }` |
| `/api/tasks/<id>` | DELETE | Deletes the specified task. | — |
| `/api/tasks/<id>/complete-qr` | POST | Marks a task `done` when the submitted QR payload matches the stored value. | `{ "qr_code": "string" }` |

Each task document includes `id`, `title`, `assignee`, `dueDate`, `status`, and `qr_code`. The backend stores these records in `backend/data/tasks.json` and keeps the QR value as a JSON-encoded matrix generated by the [`qr`](https://pub.dev/packages/qr) package.

### Real-time Updates
Connect to the `/ws` endpoint with a WebSocket client to receive push notifications. The server broadcasts a JSON message whenever a task is created, updated, deleted, or completed:

```json
{
  "event": "task:updated",
  "action": "created|updated|deleted|completed",
  "task": { "id": "...", "title": "...", "assignee": "...", "dueDate": "...", "status": "...", "qr_code": "..." }
}
```

Use these events to keep connected clients synchronized with the current task list.

## Database & Persistence Workflow
The `backend/` package contains shared database helpers, SQL migrations, and local development tooling for PostgreSQL.

### Initial Setup
1. Copy the example environment file and adjust it as needed:
   ```bash
   cp backend/.env.example backend/.env
   ```
2. Install dependencies for the Dart package:
   ```bash
   dart pub get --directory backend
   ```

### Running PostgreSQL Locally
Use Docker Compose to provision PostgreSQL with persisted storage:

```bash
cd backend
docker-compose up -d
```

This launches a Postgres 15 container with the credentials defined in `.env.example`.

### Applying Database Migrations
After PostgreSQL is running, execute the migration tool to apply all SQL files in `backend/migrations/`:

```bash
cd backend
dart run tool/migrate.dart
```

The script loads `DATABASE_URL` from the environment, applies any pending migrations in order, and records them in the `schema_migrations` table. Rerunning the command is safe—it skips migrations that are already applied.

## Flutter Mobile App
The mobile client is a Flutter application that caregivers use in the field to view schedules, receive push notifications, record visit outcomes, and synchronize data with the backend service when connectivity is available. The Flutter code now lives in the `homecare_app/` project directory.

### Prerequisites
- Flutter SDK 3.19+
- Dart 3.3+
- Android Studio or VS Code with Flutter/Dart extensions
- Xcode 15+ for iOS builds (macOS only)
- An Android emulator or iOS simulator/device

### Configuration
Create a `.env` (or use Dart define flags) in the Flutter project to point to your backend API. The most common configuration is the base API URL used for HTTP requests.

```
API_BASE_URL=http://localhost:3000
SENTRY_DSN=
GOOGLE_MAPS_API_KEY=
```

You can either load these values with a package such as `flutter_dotenv` or pass them at runtime:

```
flutter run --dart-define=API_BASE_URL=http://10.0.2.2:3000 --dart-define=SENTRY_DSN= --dart-define=GOOGLE_MAPS_API_KEY=
```

### Running the Flutter App Locally
1. Ensure the backend server is running so the mobile client can authenticate.
2. Navigate to the Flutter project: `cd homecare_app`.
3. Fetch dependencies: `flutter pub get`.
4. Format and analyze (optional but recommended):
   - `flutter format lib`
   - `flutter analyze`
5. Launch the application, providing the backend base URL that should be injected into the runtime configuration:
   ```
   flutter run \
     --dart-define=BACKEND_BASE_URL=http://10.0.2.2:8080 \
     --flavor dev
   ```

### Local notifications
- Copy the same configuration used for regular builds before testing reminders. Either create/update `homecare_app/.env` with the required keys (for example `API_BASE_URL`, `SENTRY_DSN`, and `GOOGLE_MAPS_API_KEY`) or provide them with `--dart-define` flags when you run `flutter run` or `flutter test`.
- Grant notification permissions on your test device:
  - **Android 13+ (API 33+)**: After the app prompts for notifications, verify the permission in **Settings → Apps → Homecare → Notifications**. Toggle **Allow notifications** on if it was denied.
  - **iOS**: Accept the in-app prompt or enable it later under **Settings → Homecare → Notifications → Allow Notifications**.
- Exercise the reminder flow end-to-end:
  1. Launch the app, create a new task with a scheduled reminder, and note the reminder time.
  2. Background or lock the device and wait for the local notification to appear at the scheduled time.
  3. Open the notification, complete the task, and confirm that the reminder entry is cleared or marked as cancelled inside the task detail screen.
- Troubleshooting tips:
  - Some emulators/simulators throttle alarms when the host machine sleeps or when background execution limits are active; prefer physical devices for confirmation testing.
  - Ensure the Android notification channel used for reminders exists and has **Importance: High** (check under **Settings → Apps → Homecare → Notifications → Notification categories**).
  - If no alert arrives, verify that the reminder job was scheduled in the debug logs and that the device’s **Do Not Disturb** mode is disabled.

### Build Artifacts
- **Android:**
  ```
  flutter build apk --dart-define=BACKEND_BASE_URL=https://api.example.com
  ```
- **iOS (on macOS):**
  ```
  flutter build ios --dart-define=BACKEND_BASE_URL=https://api.example.com
  ```

The `BACKEND_BASE_URL` value is consumed by `env.dart` through `String.fromEnvironment`, ensuring the router and services point to the correct API endpoint in every build.
6. Run integration tests if available: `flutter test`.
7. Launch the app on an emulator or device, again supplying the backend URL: `flutter run --dart-define=BACKEND_BASE_URL=http://10.0.2.2:8080`.
8. For iOS, open `ios/Runner.xcworkspace` in Xcode and run on a simulator or device after running `flutter pub get`.

## Coordinating Backend and Mobile Development
- Start PostgreSQL and (optionally) Redis before running the backend.
- Export the same environment variables for both backend and Flutter to keep URLs and feature toggles aligned.
- When testing on Android emulators, use `http://10.0.2.2:3000` to reach the backend running on your development machine. For iOS simulators, use `http://127.0.0.1:3000`.
- Keep your backend API documentation (e.g., Swagger/OpenAPI) up to date so the Flutter team can implement new features quickly.

## Additional Tips
- Use tools like `npm run lint` (backend) and `flutter analyze` (mobile) as part of your CI pipeline.
- Consider Docker Compose to spin up PostgreSQL, Redis, and the backend API together, then point the Flutter client at `http://localhost:3000`.
- Document any feature flags or optional modules in both backend and mobile READMEs to help new contributors get started quickly.
